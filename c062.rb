#問題
# メロンが大好きなあなたは、回転寿司のお店にメロンを食べに行きました。
# ネタはそれぞれ皿にのって 1 つずつ流れていきます。


# あなたはメロンを食べきるのに、自分の前に 10 皿流れていく程度の時間がかかります。
# メロンを食べている最中は新たにメロンを取ることができません。

# あなたがお店に滞在している間に流れてくる皿の数 T と流れてくるネタのリストが与えられるので、滞在時間中に食べられるメロンの数を出力するプログラムを作成してください。

# メロンはリスト上では "melon" という文字列で表されます。また、滞在時間が終わった時に食べているメロンは最後まで食べるものとします。



# 入力される値
# 入力は以下のフォーマットで与えられます。

# T
# n_1
# ...
# n_T
# ・1行目に流れてくる皿の数を示す整数 T が入力されます。
# ・続く T 行に流れてくるネタを示す文字列 n_i (1 ≦ i ≦ T) が入力されます。
# ・入力は合計で T + 1 行となり、入力値最終行の末尾に改行が 1 つ入ります。

# それぞれの値は文字列で標準入力から渡されます。



# 期待する出力
# 食べられるメロン "melon" の数を出力してください。

# 末尾に改行を入れ、余計な文字、空行を含んではいけません。



# 条件
# すべてのテストケースにおいて、以下の条件をみたします。

# ・1 ≦ T ≦ 2000
# ・n_i (1 ≦ i ≦ T) は長さ 10 以下の半角英字小文字の文字列



#解答コード



t = gets.to_i
sushi = []
t.times do
    sushi << gets.chomp
end

count = 0
next_melon = 0

sushi.each_with_index do |sh, i|
    if sh == "melon" && i >= next_melon
        count += 1
        next_melon = i + 11
    end
end    

puts count   



#解答時間　25分12秒
#学習ポイント
#次のメロンまでの皿数カウント方法。
#sushi配列を作成する。
#countで食べたメロンの数をカウントする。(初期値0)
#next_melonで次に来るメロンまでの皿数を記録する。
#sushi配列から一つずつsushiとインデックス番号を取り出す。
#もしsushiがmelonかつ、インデックス番号が次のメロンまでの皿数以上なら、countを+1、next_melonに11する。
#(メロンを食べるのに10皿分時間がかかるので、食べられない期間はi..i + 10。次にメロンを食べられるのはi + 11の時。)

