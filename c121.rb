#問題
# あなたは、レストランに来ています。あなたはこのレストランの人気メニュートップ 10 を全て食べようと思っていますが、どのメニューがトップ 10 に入っているかを知りません。

# あなたは来店前に、トップ 10 に入りそうなメニュー N 品 (10 品以上) をあらかじめリストアップしておきました。レストランでは、事前に作成したリストの順に 1 品ずつ注文していきます。
# リストアップした N 品の中にトップ 10 のメニューすべてが含まれているようですが、あなたには 1 日に摂取できるカロリーの上限があり、摂取するカロリーの合計はこの上限以下でなければなりません。

# リストアップした N 品のメニューの人気順位とカロリーが食べる順に与えられます。順番に食べた時、カロリーの上限を越える前に人気メニュートップ 10 を食べることができたかを判定してください。できない場合、トップ 10 のメニュー何品を食べられたかを出力してください。



# 入力される値
# 入力は以下のフォーマットで与えられます。

# N C
# r_1 c_1
# r_2 c_2
# ...
# r_N c_N
# ・1 行目には、注文した品数、摂取カロリーの上限を表す整数 N, C がこの順に半角スペース区切りで与えられます。
# ・続く N 行のうちの i 行目 (1 ≦ i ≦ N) には、それぞれ i 番目のメニューの人気順位、カロリーを表す整数 r_i, c_i がこの順に半角スペース区切りで与えられます。
# ・入力は合計で N + 1 行となり、最終行の末尾に改行が 1 つ入ります。

# それぞれの値は文字列で標準入力から渡されます。



# 期待する出力
# トップ 10 のメニューを全て食べられた場合は "Yes" を出力してください。
# 食べ切れなかった場合は、食べたトップ 10 のメニューの数を出力してください。



# 条件
# すべてのテストケースにおいて、以下の条件をみたします。

# ・10 ≦ N ≦ 50
# ・10 ≦ C ≦ 10,000
# ・1 ≦ r_i ≦ 100 (1 ≦ i ≦ N)
# ・r_i ≠ r_j (1 ≦ i, j ≦ N, i ≠ j)
# ・1 ≦ c_i ≦ 10,000 (1 ≦ i ≦ N)
# ・r_i には、1 ~ 10 が全て必ず含まれていることが保証されています。



#解答コード



n, c = gets.chomp.split.map(&:to_i)
ranking = []
n.times do
    r, c_i = gets.chomp.split.map(&:to_i)
    c -= c_i
    if c >= 0
        ranking << r
    else    
        break
    end   
end    

count = ranking.count { |num| (1..10).include?(num) }

if count == 10
    puts "Yes"
else
    puts count
end    



#解答時間　15分24c秒
#学習ポイント
#制限カロリー内でのランキングリスト取得方法。
#ranking....食べることのできたメニューのランキング配列。
#制限カロリーからメニューのカロリーをマイナスする。
#もし制限カロリーの残数が0以上なら、メニューをrankingに追加する。
#残カロリーが0未満になった時点で終了する。
#rankingから要素を取り出し、1から10の中にランクインしているものの数をカウントする。
#もしトップ10メニューを食べることができたら(countが10)Yesを出力する。
#食べられなかった場合は何品食べられたか(count)を出力する。